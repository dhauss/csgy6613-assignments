# Assignment 3: Kalman Filter

Date of Submission: 4/8/2024

## Instructions on How to Run Code
This code will most easily be run in Google Colab. I've included a requirements.txt file to run it locally, but to run in Colab I included all necessary library installations and dependencies in the first two cells of each notebook. The requirements.txt files contains all requirements for both notebooks. If running locally, be aware that some functionality is Colab specific: there is a patch for cv2.imshow() as well as some colab specific file manipulation functions.

## File Structure

I split the main functionality between two notebooks: [drone_follow_me_object_detection.ipynb](https://github.com/dhauss/csgy6613-assignments/blob/main/assignment-3/drone_follow_me_object_detection.ipynb), which implements the training and testing of a YOLO v8 object detection model, and [drone_follow_me_kalman_filter.ipynb](https://github.com/dhauss/csgy6613-assignments/blob/main/assignment-3/drone_follow_me_kalman_filter.ipynb), which implements and tests Kalman Filters using the detection model trained in the first notebook. I have also included the [trained YOLO v8M model](https://github.com/dhauss/csgy6613-assignments/blob/main/assignment-3/yolov8m_150_epochs_metrics/yolov8m_150_epochs_best.pt) I used for object detections, as well as key metrics from the [YOLO v8X model](https://github.com/dhauss/csgy6613-assignments/tree/main/assignment-3/yolov8x_metrics), [YOLO v8L model](https://github.com/dhauss/csgy6613-assignments/tree/main/assignment-3/yolov8l_metrics), the initial [YOLOv8M test model](https://github.com/dhauss/csgy6613-assignments/tree/main/assignment-3/yolov8m_metrics), as well as the [final YOLOv8M model](https://github.com/dhauss/csgy6613-assignments/tree/main/assignment-3/yolov8m_150_epochs_metrics) which I used for my Kalman Filter implementation. Note that after clearly poor performance, I forgot to save many of the metrics from the YOLOv8X as explained further in [drone_follow_me_object_detection.ipynb](https://github.com/dhauss/csgy6613-assignments/blob/main/assignment-3/drone_follow_me_object_detection.ipynb). As these notebooks were originally run in Colab, be aware that any harcoded filepaths will have to be updated to run the code locally. The paths to the three original YouTube videos should, however, work in any environment.

## Video Links

Object detection-specific results can be found in [drone_follow_me_object_detection.ipynb](https://github.com/dhauss/csgy6613-assignments/blob/main/assignment-3/drone_follow_me_object_detection.ipynb), but the overall results with Kalman Filters can be found in the following links: [Cyclist and Vehicle 1 KF Results](https://drive.google.com/file/d/14W7ChiQRnKRP8J7tEGpJmXRKQ01ql0zB/view?usp=sharing), [Cyclist and Vehicle 2 KF Results](https://drive.google.com/file/d/1-DNH1ccXEOfYmqHZbdyDpYnfvIUfpYWe/view?usp=sharing), [Drone Tracking KF Results](https://drive.google.com/file/d/1-2ZTJT3SXwRoevmNC06Qo-AUgwbYJmUy/view?usp=sharing), and [Extra Credit Video KF Results](https://drive.google.com/file/d/1-EQ1W0Ybfi3BGOuaEl_pxvQe1y5CuKc8/view?usp=sharing), though note that all of these links can also be found within [drone_follow_me_kalman_filter.ipynb](https://github.com/dhauss/csgy6613-assignments/blob/main/assignment-3/drone_follow_me_kalman_filter.ipynb)

## Kalman Filter Implementation

I implement a Kalman Filter with a constant velocity model, and use a simple 1-NN algorithm with a minimum distance threshold to account for false positives, in order to track cyclists and cars in four videos filmed from a drone. The objects are detected using a Yolo v8M model trained from scratch on the [Visdrone dataset](https://universe.roboflow.com/visdrone/visdrone-lzsy1). When no viable object candidates are detected, I update the Kalman Filter using its own previous prediction. This allows for continuity in the predicted trajectory, and works especially well in the [Extra Credit Video KF Results](https://drive.google.com/file/d/1-EQ1W0Ybfi3BGOuaEl_pxvQe1y5CuKc8/view?usp=sharing).

I initially attempted a constant acceleration model, but found that the false positives would often cause the acceleration to increase drastically. In hindsight, my later implementation of a minimum threshold may have fixed this issue, and it would be interesting to see how a constant acceleration model would perform with the improved object detection logic.
